import de.grogra.vecmath.Math2;
import de.grogra.vecmath.Matrix34d;
import de.grogra.numeric.*;
import de.grogra.numeric.cvode.*;
import de.grogra.ext.x3d.util.Util;
    
/********************************************* 
				SIMULATION PARAMETERS
************************************************/

//Runinfo                                  
static int time;
static int Max_Step 			= 100;				// days	150 for validation
static int dataTime				= 100;				// 124 for validation
static int NrTreatments			= 150;
static int NrReps				= 1;
static int NrRuns				= NrReps*NrTreatments;// number of runs
static int runcounter			= 0;				// run counter
static double IntStep			= 1; 				// number of integration steps per time step

//Number of Plants
static int nrRows				= 1;				// number of rows in the field
static int nrPlants				= 1;				// number of plants per row
static int NrBorderPlants		= 0;				// number of plants that are assigned to exclude the border effect
static double rowDistance		= 0.1;				// distance between rows
static double plantDistance		= 0.1;//0.18;		// distance between plants within the row
static int NrClones				= 1;

//Species
static int nul = 0; static int def = 1; static int sas = 2; static int defsas = 3; static int gdtrade = 4; static int local = 5; static int syst = 6; static int systp = 7; static int sp1 = 8; static int sp2 = 9;
static double fRandom			= 0;				// stochasiticity factor
 
//Temperature
static double GDD = 1.0;									// average temperature in degree days
 
/********************************************* 
				LAYERING
************************************************/

const int RootLayer 		= 4;
const int GridPointLayer	= 6;
const int BoxLayer			= 9;
const int BaseLayer			= 13;
 
/********************************************* 
				ROOT PARAMETERS
************************************************/

static int FirstSpecies			= 0;					//0=variable, 1=static
static int SecondSpecies		= 0;					//0=variable, 1=static

static boolean RootPlasticity[]	= {false,false};

//Growth
static double Dinit[]			= {0.0011,0.0011};		// Initial root Diameter in m
static double RTD				= 0.05;					// Root tissue density (g/cm3)
static double EL				= 18;					// Elongation rate,mm mm-1 day-1

//Monocots
static int MP[]					= {10,0};				// Maximum number of root primordia
static double ER				= 0.056;				// Emergence rate of root primordia per day = 0.968 at 25 degrees which is 0.056 per dregreeday.
//biomass
static double LM 				= 1;  //assign the initial shoot biomass
static double RM 				= 1;  //assign the initial root biomass


//Branching
static double IBD[]	 			= {0.0078,0.0078};		// Inter Branch Distance
static double RZone				= 0.01;					// No lateral zone in m
static double RSP[]				= {0.5,0.5};			// Ratio between secondary and primary roots
static double sdD[]				= {0,0};				// Standard deviation diameter for RDM
static double RTS[]				= {0.375,0.375};		// Ratio between tertiary and secondary roots
static double angleAVG			= 60;					// average insertion angle of lateral roots
static double angleVAR			= 20;					// variation in the insertion angle of lateral roots
static double MCP[]				= {50,50};				//random root movement based on mechanical staticraints; radial degrees/m
static int MaxRootOrder			= 1;

//Fine roots	
static double fAbsRoots[]		= {32,40};				// ratio of biomass allocation to absorptive/transport fine roots 	

//Root mass fraction
static double RLratio[]			= {1,1}; 				// Root/Leaf ratio

//Uptake for !RootModule
static double Vmax				= 10;  				// Max uptake rate in umol m-2 s-1 (DUNBABIN 2002)
static double Km				= 25000; 				// MMenten staticant in umol m-3 
static double LATSmin			= 10; 					// mmol L-1 or mol m-3
static double rhizR				= 10; 				// depth of the rhizosphere in m

//Tropism variables
static double Groot				= 0.0075;				// Base rate of Gravitropism 

//Rootsystem Parameters
static double SRL				= 100;					// Specific root length, m g-1
static double RSratio 			= 10; 					// Target root/shoot ratio
static double Rt				= 0.00001;				// root turnover
static double CNconversion 		= 0.014;				// Conversion of C to N in case the rootModule is turned off
static double NSoil				= 10;					// mM N/L Soil
static double soilDepth			= 0.3;					// soil depth
static double avgRootR			= 0.00105;				// average root radius

/********************************************* 
				SOIL PARAMETERS
************************************************/

static boolean infiniteSoil 	= true;

//Soil Grid
static double SoilDepth			= 1;					// depth of the soil compartment in m
static double CellSize			= 0.1;					// size of a cubical soil cell m 0.09

//Resource concentrations; 
static double soilN0			= 350;					// N content of the low nutrient treatment in uMol N / L soil
static double soilP0			= 15;					// P content of the low nutrient treatment in uMol P / L soil
static int N_Scenario			= 0;
static double soilN[] 			= {soilN0,soilN0*10}; 	// uMol N/L soil
static int P_Scenario			= 1;
static double soilP[]			= {soilP0,soilP0*10}; 	// uMol P/L soil

//Uptake kinetics ()
static double N_UptakeRadius	= 0.03;					// N uptake radius in m
static double P_UptakeRadius	= 0.002;				// P uptake radius in m; 0.001 for short root hairs, 0.002 for long root hairs, see Gahoonia & Nielsen 1997
static double N_Cmin_r			= 2;					// uMol/L (York 2016)
static double N_Cmin_mf			= 2;					// uMol/L 
static double P_Cmin_r			= 1.2;					// uMol/L (Silveira 2004)
static double P_Cmin_mf			= 0.3;					// uMol/L (Silveira 2004)

//MF paramters
static double fMyc[]			= {0,0};				// ratio biomass allocation to MF/roots, baseline = 0.063 from Jakobsen & Rosendahl 1990
static double MFradius 			= 2.5e-6;
static double P_UptakeRadius_MF = 0.001;				// assumed equal to roots with short root hairs, see Gahoonia & Nielsen 1997
static double N_ret_mf			= 0.05;					// fraction Nitrogen retention by AMF in g N per g biomass (Hodge & Fitter 2010)
static double MFTD				= 0.22;					// mycorrhizal tissue density

/********************************************* 
				SHOOT PARAMETERS
************************************************/
 
static double Nmin		= 0.0053;				// Structural nitrogen requirements
static double Nmax		= 0.053;				// Nitrogen content at which photosynthesis is maximised
static double NPratio	= 15;					// N:P ratio where the plant is equally limited by N and P
static double Pmin		= Nmin/NPratio;			// Structural Phosphorous requirements
static double Pmax		= Nmax/NPratio;			// Phosphorous content at which photosynthesis is maximised	
static double StrucN	= Nmin;			// fraction of structural Nitrogen (g/g)
static double StrucP	= Pmin;			// fraction of structural Phosphorous (g/g)
 
// Flowers and seeds
static double SeedWeight	= 0.000837;			// weight (g) per seed (0.000837)

//Nutrient Demands
static double Cc_R			= 1.34;				// Root Construction Costs in g Glucose per g biomass

/********************************************* 
				Light METHODS
************************************************/

static int rayCount = 500;					// number of light rays
static int depth = 10;							// maximum number of scattering
static LightModel lm = new LightModel(rayCount,depth);	// for paper: 1 or 5 million rays
 
static double reflectancePAR = 0.110376;		// reflectance for PAR
static double transmittancePAR = 0.07612;		// transmittance for PAR
const double reflectanceRed = 0.0482;			// reflectance for red
const double transmittanceRed = 0.0329;			// transmittance for red
const double reflectanceFarRed = 0.3772;		// 0.52 reflectance far-red
const double transmittanceFarRed = 0.4846;		// 0.42 transmittance for far-red

const Phong LightShader = new Phong().(setDiffuse(new RGBColor(reflectancePAR,reflectanceRed,reflectanceFarRed)), setDiffuseTransparency(new RGBColor(transmittancePAR,transmittanceRed,transmittanceFarRed)));
const Phong SoilShader = new Phong().(setDiffuse(new RGBColor(0,0,0)), setDiffuseTransparency(new RGBColor(1,1,1)));

/********************************************* 
				MAIN
************************************************/

static int id;

//execution rules
public void run()
{
	if (time<=Max_Step) {
		Soil.Uptake();					//@ SimpleSoilModule
		integrate(1);
		Update();						//@ Update
		Develop();						//@ Develop
		time++;
		println(" time " + time + "Run " + runcounter);
 	}
/* 	else { 
		runcounter++;
		if(runcounter<NrRuns) {
			//reset();
			runcounter++;
			println("Run " + runcounter);
		}
	} */
	//;
}

//Initiation rules
protected void init ()
{
 	SetupPlot();					//@ Init
 	//setSolver
	//non-stiff problems:
	setSolver(new org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator(5,0, 1, 1E-6, 1E-6));
}

static void SetupPlot() 
[
	Axiom ==> 
		if(NrClones>0) (GridClonerNode(NrClones, nrRows*rowDistance, NrClones, nrPlants*plantDistance))				
		for( int r=1; r<=nrRows; r++) (
			for (int c=1; c<=nrPlants; c++) (
			[	
				Translate((r-0.5)*rowDistance,(c-0.5)*plantDistance,0)
				pb:Plantbase(id,0,0,true)			//@Class				
				dummy(0,id,r,c,pb)		//@ShootModule
				dummy(1,id,r,c,pb)		//@RootModule
				{id++;}
			]
			)
		) {id=0;};
		
		/******************************
				INITIATE MODULES
		******************************/
		{
			derive();
			initRoot();								//@RootModule
			initSoil();								//@SoilModule
		}
]


static void Develop() {
	DevelopRoot();		// @ RootModule
}

static void Update() [
	o:RootSystem ::> o.update();			
]

/********************************************* 
				CLASS
************************************************/


 /* a general class for passing information to different classes
 *  rs, organ type
 *  i for id, r for row number, c for plant number 
 */
module dummy (int rs, int i, int r, int c, Plantbase pb) {}

abstract module Organ(super.length) extends M(length)
{
	//descriptive variables
	int ID;
 	
	int order;
	int rank;
	int age;
	double ThermalAge;
	
	void update() {
		calcAge();
	}
	
	void calcAge() {
		age :+= 1;
		ThermalAge :+= GDD;
	}
	
	//Source-Sink related variables @SourceSink
	double volume;  //in m3
 	double crossArea;
	double biomass;
	double rm;
	double cc;
	double Sink;
	double CFlux;
	double fAllocated;		// fraction of assimilates allocated
	double assimilates;
	double Ni;
	double Pi;
	boolean SourceSink=true;	//denotes wether an organ takes part in the source-sink distribution
	boolean green=true;			//a green organ is both a sink and a source, while a non-green or senesced organ is no longer a sink, which makes resorbtion of assimilates possible
	
	void calcSink(){}
	Plantbase pb;
}
 
module Plantbase
{
	//descriptive variables
	int ID;
 	
	int order;
	int rank;
	int age;
 	double ThermalAge;
	
	//Source-Sink related variables
	double rm;
	double Ni;
	double Pi;
	double water;
	double nitrogen;
		
	void calcAge() {
		age :+= 1;
		ThermalAge :+= GDD;
	}
	
	void update() {
		calcAge();
  	}
	
	public Plantbase(int id, int st, int sp, boolean trmt) {
		ID = id;
		Ni = 0.2*SeedWeight;
		Pi = 0.1*SeedWeight;
	}
	
} ==> Cylinder(0.00000001,0.05).(setShader(BLUE), setLayer(BaseLayer));
 
/********************************************* 
				SOURCE SINK
************************************************/
/* 
class SourceSink {

	//Based on the construction of the graph, the maximum number of edges that seperate two organs
	static int MaxNrEdges = 4;
	
	static double NThresh = 1.5;
 
 	static void calcAssimilateFlux() [
		a:Organ (-->){1,MaxNrEdges} : (b:Organ), (a.SourceSink,b.SourceSink) ::> {
			double D = 10;
			double S0 = a[assimilates]/Math.max(a[length],0.01);
			double S1 = b[assimilates]/Math.max(b[length],0.01);
			double flux = D * (S0-S1);
			a[assimilates] :'= -flux;
			b[assimilates] :'= +flux;
		}
	]

} */

/********************************************************************************
	RootSystem
********************************************************************************/

/********************************************* 
				MODULES
************************************************/
//This represents the whole root system
module RootSystem extends Organ
{	
	int species;
	double surfaceArea;			// root surface area

	double width;
	double depth = soilDepth;
	
	double rootLength;
	double rootVolume;
	double rhizArea;
	double soilN;
	
	double Uptake_W;
	double Uptake_N;
	double Uptake_P;
	double Uptake_N_MF;
	double Uptake_P_MF;
	
	double sumGrowth;  //sum of all growth demand
	double RM = 10;  //Root mass
	
	//Monocot
	double NrRP;
	double ER;
	
	//Mycorriza
	double MycBiomass;
	double MycLength;
	double MycSurfaceArea;
	
	double calcRM(double LM) { //  Root leaf ratio
		return LM*RLratio[species];		
	}
	
	void calcSink() {
		//calculates the organs sink strength
		//rm = biomass * Rm; // Calculate root mass.
		//double LM = sum((*i:Leaf, (i.ID==ID&&i.green)*)[biomass]) + sum((*i:Cotyl, (i.ID==ID)*)[biomass]); //Leaf mass
		//RM = calcRM(LM); 
		//Sink = Math.max(0, RM - biomass) + rm;
	}
	
	void calcGrowth() {
		//converts allocated assimilates to growth
		// **Constants** //
		CFlux = 2E-4; //  Carbon flux
		// StrucN = 0.0053; fraction of structural Nitrogen
		// StrucP = 3.533333333333333E-4; fraction of structural Phopspherous
		// **Constants** //
		pb.Ni -= CFlux*StrucN;
		pb.Pi -= CFlux*StrucP;
		biomass += CFlux;
		
		//reset counter
		sumGrowth = 0;
		
		//create a root system from biomass
		if(CFlux>0) [ // Primary, secondary, and apex
				r:GrowingRootOrgan, (r.ID==ID) ::> r.calcSink(this);
				r:GrowingRootOrgan, (r.ID==ID) ::> r.calcGrowth(this);
		]
	}
	
	void Uptake() {	
		[ // Apex and secondary root only.
			r:ExtendingRootOrgan, (r.ID==ID) ::> r.getUptake(this);
		]  
	}
	
	public RootSystem(dummy d) {
		//constructor
		length = 0.00001;
		println(length);
		ID = d.i;
		cc=Cc_R;
		soilN = volume*1000*NSoil;		//uMol
		pb = d.pb;
	}
	
	void update() {
		calcAge();
		calcGrowth();
		Uptake();
	}
	
}; //==> if(!true) (RU(180) M(0.001) Box(depth,length,width).(setLayer(RootLayer)));

/*Root organ base module*/
abstract module RootOrgan extends Organ
{
	
	int species;
	boolean border;
	
	
	double Ci;					// total carbon allocated to the root
	double C;                  // allocated carbon in each time step
	double surfaceArea;			// root surface area

	double D;					// diameter
	double radius;				//assumed this is in meter	
	double LD;					// life duration

	Shader RootShader = BLACK;
	
	double MF;
	double FineRootLength;
	double FineRootBiomass;
}

/*Root organs that are a carbon sink*/
abstract module GrowingRootOrgan extends RootOrgan
{
	void calcSink(RootSystem RS) {}
	void calcGrowth(RootSystem RS) {}
	
	double potGrowth;
	double pRoot;				//potential root growth
	double pMF;					//potential MF growth
	double MFnew;
}

/*Root organs that extend the root system and therefore contribute to uptake*/
abstract module ExtendingRootOrgan extends GrowingRootOrgan 
{
	boolean Explored = false;	//all growing roots get checked for explored soil
	double newRootLength;
	
	double Uptake_N;
	double Uptake_P;
	double Uptake_N_MF;
	double Uptake_P_MF;
	double Uptake_N_MF_notshared;
	double Uptake_P_MF_notshared;

	void getUptake(RootSystem RS) {
		RS.Uptake_N += Uptake_N + Uptake_N_MF;
		RS.Uptake_N_MF += Uptake_N_MF;
		RS.Uptake_P += Uptake_P + Uptake_P_MF;
		RS.Uptake_P_MF += Uptake_P_MF;
		RS.pb.Ni += ((Uptake_N+Uptake_N_MF)/1000000)*14;
		RS.pb.Pi += ((Uptake_P+Uptake_P_MF)/1000000)*31;
		resetUptake();
	}
	
	double getFineRootD() { // Ratio between tertiary and secondary roots.
		return D*RTS[species];
	}
	
	void resetUptake() {
		//resets uptake
		Uptake_N := 0;
		Uptake_P := 0;
	}
	
	void ExploreSoil() {
		//check location
		Point3d loc = this instanceof Apex ? location(this) : endlocation(this);
		//Check if in an explored part of the soil volume
		if(empty((*e:ExploredSoil, (loc in volume(e))*))&&endlocation(this).z<0) {
			//if not, explore
			Soil.Explore(this); 
		}
		//this root is now in a piece of explored soil volume 
		Explored = true; 
	}
}

/*Apices that extend the root system*/
module Apex extends ExtendingRootOrgan
{
	int GD;				// growth Duration in degreedays
	double Cimin;		// carbon needed to make a rootSegment
	
	//rotation fields
	double rotX;
	double rotY;
	double rotZ;
	double bAngle;
	
	void calcSink(RootSystem RS) {
		//calculates the organs sink strength, scaled to root diameter
		//EL mm mm-1 day-1
		//D in meter
		//assume radius did not change
		//RTD root tissue density 0.05 g/cm3
		//1e6 convert m3 to cm3
		//pRoot is in gram
		pRoot = EL*D * Math.PI*(radius*2)**2 * RTD*1e6 ; // Potential root growth
		
		//new calculation for MF 
		pMF = fMyc[species]*pRoot;
		
		//potential growth
		potGrowth = pRoot + pMF; // Sum of root and mycorrhizal growth
		
		RS.sumGrowth += potGrowth; // Take using from every apex
	}
	
	void calcGrowth(RootSystem RS) {
		//converts allocated assimilates to growth
		C = potGrowth>0 && RS.sumGrowth>0 ? (pRoot/potGrowth) * RS.CFlux * potGrowth/RS.sumGrowth : 0; // Check potential growth > 0
		//C = 4.525346100342965E-6;
		
		MFnew = potGrowth>0 && RS.sumGrowth>0 ?  Math.max(0,(pMF/potGrowth) * RS.CFlux * potGrowth/RS.sumGrowth) : 0;  // Check potential growth > 0
		MF += MFnew;
		Ci += C;
		biomass += C;
		newRootLength = getIBD() * C/Cimin;
		length = getIBD() * Ci/Cimin;
		surfaceArea = length*2*Math.PI*radius;
	}
	
	/***************************
		FUNCTIONAL RESPONSES
	****************************/
	
	double getGravitropism() {
		//Gravitropism as a function of ...
		return  Groot *(D*1e3); // Gravitropism rate * diameter * scaling factor
	}
	
	double getAngle() { // Effects the apex
		//lateral root angle as a function of ...
		return normal(angleAVG, angleVAR); // Stochastic (normal distribution)
	}
	
	double getRDM() {
		//diameter reduction of lateral roots as a function of ...
		return RSP[species]; // Ratio between secondary and primary roots
	}
	
	double getIBD() { // {0.0078,0.0078};		// Inter Branch Distance
		//distance between lateral roots, 
		//with the highest root oder having longer segments to improve computation time
		//double ibd = order<MaxRootOrder ? IBD[species] : IBDmax;
		double ibd = IBD[species];
		// carbon needed to make a rootSegment
		Cimin = (ibd*Math.PI*(radius)**2)*(RTD*1e6)*Cc_R; // RTD = Root tissue density, root construction costs = CC_R 
		//Cimin = 4.966433870317228E-4;
		return ibd;
	}
	
	/*******************************/
	
	void rotate(double x, double y, double z) {
		//set rotation
		rotX = x; 
		rotY = y;
		rotZ = z;
		setRotation(x,y,z);
	}
	
	public Apex(int o, int r, int id, int sp, double Dm, Plantbase p) {
		//t=0 constructor
		length = 0;
		D = Dm;
		radius = 0.5*D;
		crossArea = Math.PI*radius**2;
		Ci = 1e-5;
		order = o;
		rank = r;
		ID = id;
		species = sp;
		Cimin = (IBD[species]*Math.PI*(radius)**2)*(RTD*1e6)*Cc_R;
		rotX = Math.PI*random(-MCP[sp],MCP[sp])/180;
		rotY = Math.PI*random(-MCP[sp],MCP[sp])/180;
		rotZ = Math.PI*137.5/180;
		surfaceArea = 1E-16;
	}
	
	public Apex(RootOrgan s, double Dm, double x, double y, double z, double a) {
		//seminar and lateral constructor
		length = 0;
		D = Dm;
		radius = 0.5*D;
		crossArea = Math.PI*radius**2;
		order = s.order+1;
		rank = s.rank;
		ID = s.ID;
		species = s.species;
		Cimin = (IBD[species]*Math.PI*(radius)**2)*(RTD*1e6)*Cc_R;
		rotX = x;
		rotY = y;
		rotZ = z;
		bAngle = a;
		setRotation(x+a,y,z);
		surfaceArea = 1E-16;      
	}
		
} ==> Cylinder(length,radius).(setShader(BLACK), setLayer(RootLayer));

/*Primary root segments showing radial growth*/
module PrimaryRootSegment extends GrowingRootOrgan 
{
	void calcSink(RootSystem RS) {
		//primary roots grow radially
		pRoot = calcRadialSink(); // Radial growth = sum of cross area of apices.
		//calculate MF allocation
		pMF = fMyc[species]*pRoot; //  ratio biomass allocation to MF/roots, baseline = 0.063 from Jakobsen & Rosendahl 1990
		//calculate potential growth
		potGrowth = pRoot + pMF;
		RS.sumGrowth += potGrowth;
	}	
	
	double calcRadialSink() {
		double sumArea = sum((*this (-->)* a:Apex*)[crossArea]);
		double newMass = length * sumArea*RTD*1e6;
		return newMass-biomass;
	}

	void calcGrowth(RootSystem RS) {
		//C allocated to radial growth
		C = potGrowth>0 && RS.sumGrowth>0 ? (pRoot/potGrowth)*RS.CFlux * potGrowth/RS.sumGrowth : 0; // check potential growth> 0; scaling by potential root growth per root organ.
		biomass += C;

		radius = Math.sqrt(biomass/(length*Math.PI*RTD*1e6));
		D = radius*2;
		surfaceArea = (length * 2*Math.PI*radius);
		
		//C allocated to MF growth
		MFnew = potGrowth>0 && RS.sumGrowth>0 ?  Math.max(0,(pMF/potGrowth)*RS.CFlux * potGrowth/RS.sumGrowth) : 0;
		MF += MFnew;
	}
	
	
	
	public PrimaryRootSegment(Apex a) {
		//constructor
		
		length = a.getIBD();
 		//length =  0.0078;
 		
 		rank = a.rank+1;
		order = a.order;
		ID = a.ID;
		species = a.species;
		D = a.D;
		radius = 0.5*D;
		surfaceArea = (length * (2 * Math.PI * radius));
		Ci = a.Cimin;
		biomass = a.Cimin;
		RootShader = a.RootShader;
	}
	
} ==> Cylinder(length,radius).(setShader(BLACK), setLayer(RootLayer));	

/*Growing secondary root segments*/
module SecondaryRootSegment extends ExtendingRootOrgan 
{
	double maxFineRootBiomass = 1e-3;  //I feel this rule needs to be checked and updated
	double fFRS = 1.1;				//fraction by which to overshoot sink strength to prevent growth saturation

	void calcSink(RootSystem RS) { // Not radial growth calculation !!!
		//secondary roots grow tertiary roots
		pRoot = calcFineRootSink();
		//calculate MF allocation
		pMF = fMyc[species]*pRoot;
		//calculate potential growth
		potGrowth = pRoot + pMF;
		RS.sumGrowth += potGrowth;
		
		println("RootSystem sumGrowth" + RS.sumGrowth); 
	}	
	
	void calcGrowth(RootSystem RS) {
		//Carbon allocated to fine root growth
		C = potGrowth>0 && RS.sumGrowth>0 ? (pRoot/potGrowth)*RS.CFlux * potGrowth/RS.sumGrowth : 0;
		//C = 0;
		biomass += C;
		
		FineRootBiomass += C;
		newRootLength = C/((Math.PI*(getFineRootD()/2)**2)*RTD*1e6); // getFineRootD = Ratio between tertiary and secondary roots.
		FineRootLength += newRootLength;
		surfaceArea = (length * 2 * Math.PI * radius) + (FineRootLength * (2 * Math.PI * getFineRootD()/2));
			
		//replace the rootsegment if tert roots have formed
		if(FineRootBiomass>=maxFineRootBiomass*(1/fFRS)) { //fraction by which to overshoot sink strength to prevent growth saturation0000000000000000000000000000000000000000000000000000000000000000000000000000000000
			replace(); // Sets to old root segment
		}
		
		//C allocated to MF growth
		MFnew = potGrowth>0 && RS.sumGrowth>0 ?  Math.max(0,(pMF/potGrowth)*RS.CFlux * potGrowth/RS.sumGrowth) : 0;
		MF += MFnew;
	}
	
	double calcFineRootSink() {
		//potential increase in fineroot biomass, 
		//maxfinertbiomass is increased by a factor 1.1111 to prevent approaching but never reaching the maximum value
		//maxfinerootbiomass is 0 for primary roots and >0 for secondary roots
		return Math.max(0,maxFineRootBiomass*fFRS-FineRootBiomass); // fFRS = fraction by which to overshoot sink strength to prevent growth saturation
	}
	
	void replace() [
		//Change this rootsegment to an oldrootsegment
		this ==> oldRootSegment(this).(setTransform(this.getLocalTransformation()));
	]
	
	public SecondaryRootSegment(Apex a) {
		//constructor
		length = a.getIBD();
		//length =  0.0078;
		rank = a.rank+1;
		order = a.order;
		ID = a.ID;
		species = a.species;
		D = a.D;
		radius = 0.5*D;
		surfaceArea = (1 * (2 * Math.PI * radius));
		Ci = a.Cimin;
		biomass = a.Cimin;
		RootShader = a.RootShader;
		maxFineRootBiomass = order>0 ? fAbsRoots[species]*length * Math.PI*(getFineRootD()/2)**2 * (RTD*1e6) : 0;
		
	}
	
} ==> Cylinder(length,radius).(setShader(BLACK), setLayer(RootLayer));	

/*Secondary root segments that have stopped growing tertiary roots*/ 
module oldRootSegment extends RootOrgan
{
	double maxFineRootBiomass = 1e-3;
	
	public oldRootSegment(SecondaryRootSegment a) {
		//constructor
		length = a[length];
		rank = a.rank;
		order = a.order;
		ID = a.ID;
		species = a.species;
		D = a.D;
		radius = 0.5*D;
		surfaceArea = a.surfaceArea;
		Ci = a.Ci;
		biomass = a.biomass;
		RootShader = a.RootShader;
		FineRootLength = a.FineRootLength;
		FineRootBiomass = a.FineRootBiomass;
		MF = a.MF;
		maxFineRootBiomass = a.maxFineRootBiomass;
	}
} ==> Cylinder(length,radius).(setShader(BLACK), setLayer(RootLayer));	

/********************************************* 
				INITIATION
************************************************/

static void initRoot()	//@Init 
{
	[
		d:dummy, (d.rs==0) ==>
		{int id=d.i; int r=d.r; int c=d.c;}
		[ 
			RU(180)	RH(random(0,360))
			{int s = 0; }
			RootSystem(d)
			Apex(0,1, id, s, Dinit[s],d.pb)    //public Apex(int o, int r, int id, int sp, double Dm, Plantbase p) {
			//apex order, rand, id, species, diameter, plantbase
		
		];
	]
}

/********************************************* 
				DEVELOPMENT
************************************************/

static void DevelopRoot()	//@Develop
[		
	//DevelopApex
	ap:Apex, (ap.length>ap.getIBD()) ==> 
		do(
			{	//random variation in diamter and direction
				//RDM is the reduction in diameter
				double DM = sdD[ap.species]>0 ? normal(ap.getRDM()*ap.D, ap.getRDM()*ap.D*sdD[ap.species]) : ap.getRDM()*ap.D;
				int s = ap.species;
				double x = Math.PI*random(-MCP[s],MCP[s])/180;
				double y = Math.PI*random(-MCP[s],MCP[s])/180;
				double z = 0;//Math.PI*137.5/180;
			}
			
			//gravitropism
			RV(ap.getGravitropism())
			
			//rootsegment initiation
			if(ap.order==0) (
				r:PrimaryRootSegment(ap).(setTransform(ap.getLocalTransformation()))
			)else if(ap.order==1) (
				r:SecondaryRootSegment(ap).(setTransform(ap.getLocalTransformation()))
			)
			
			//head angle rotation and branch apex initiation
			if(ap.order <= MaxRootOrder) (
				[ RH(137.5*ap.rank) a:Apex(ap,DM,x,y,z,Math.PI*ap.getAngle()/180) ]
			)
			
			{	//update apex variables
				derive();
				ap.rank++;
				ap.Ci -= ap.Cimin;  //Cimin = carbon needed to make a rootSegment
				ap.biomass -= ap.Cimin;
				ap.rotate(x,y,z);
			}
		)while(ap.Ci>ap.Cimin)
		
		//apex
		ap
		
		{	//update apex variables
			derive();
			ap.GD+=GDD; 
			ap.length = ap.getIBD()*ap.Ci/ap.Cimin;
			derive();
		}
		
				
		;
	
	//Initiate new adventitious root primordia
	rb:RootSystem ::> 
	{
		println("rb.NrRP " + rb.NrRP + "rb.ER " + rb.ER + "MP[rb.species]" + MP[rb.species] + (rb.RM-rb.biomass));
	}
	
	rb:RootSystem, (rb.NrRP < MP[rb.species] && rb.RM-rb.biomass>0) ==> rb 
	{
		rb.ER += ER*GDD;
		println("rb.NrRP " + rb.NrRP + "rb.ER " + rb.ER);
	
	}
	
		//initiate seminal roots
		do(
		
		//random variation in diameter
		{ double DM = Dinit[rb.species]; println(rb.NrRP);}
			
			if(rb.ER>1) (
			[	//initiate a new apex
				RH(137.5*rb.NrRP+random(-10,10)) 
				RU(random(5,45)) 
				Apex(0,1, rb.ID, rb.species, DM, rb.pb)
				{ 
					rb.ER--; 
					rb.NrRP++; 
					println("rb.NrRP " + rb.NrRP + "rb.ER " + rb.ER);
				}
			])
			
		) while( rb.ER>1 )
		;
	//Consolidate changes
	{derive();}
	//redirect roots not in the soil volume
	a:Apex ,(Barrier(a)) ::> {rootDeflection(a);}
	//Consolidate changes
	{derive();}
	//redirect roots not in the soil volume
	a:Apex ,(infiniteSoil) ::> {infiniteRoot(a);} 
	//Consolidate changes
	{derive();}
	//explore new soil
	r:ExtendingRootOrgan, (!r.Explored) ::> { r.ExploreSoil(); }
		
]

/********************************************* 
				METHODS
************************************************/

static void infiniteRoot(Apex A) {
	
	//Apex location components
	double ex = endlocation(A).x;
	double ey = endlocation(A).y;
	
	if((ex<0||ex>nrRows*rowDistance||ey<0||ey>nrPlants*plantDistance)) [
	
	{//select the rootsegment that is on the edge of the soil volume
		RootOrgan R = first((* A (<)* r:RootOrgan, (
		(location(r).x>=0&&location(r).x<=nrRows*rowDistance&&location(r).y>=0&&location(r).y<=nrPlants*plantDistance) &&
		(endlocation(r).x<0||endlocation(r).x>nrRows*rowDistance||endlocation(r).y<0||endlocation(r).y>nrPlants*plantDistance) )*)); 
	}
		
	//insert a Null node in front of the Rootsegment to allow transformation
	R ==> m:Null R;
	
	//derive to instantiate the null node
	{derive();}
	
	//Transform the Rootsegment
	m:Null R ::> {
		double tx = endlocation(R).x<0 ? 1 : endlocation(R).x>nrRows*rowDistance ? -1 : 0;
		double ty = endlocation(R).y<0 ? 1 : endlocation(R).y>nrPlants*plantDistance ? -1 : 0;
		
		//Translation vector in global coordinates
		Point3d p = new Point3d(tx*nrRows*rowDistance,ty*nrPlants*plantDistance,0);
		
		//axes of the original cartesian system
		Vector3d i = new Vector3d(1,0,0);
		Vector3d j = new Vector3d(0,1,0);
		Vector3d k = new Vector3d(0,0,1);
		
		//axes of the transformed cartesian system
		Matrix4d M = transformation(m);
		Vector3d I = new Vector3d(M.m00,M.m10,M.m20);
		Vector3d J = new Vector3d(M.m01,M.m11,M.m21);
		Vector3d K = new Vector3d(M.m02,M.m12,M.m22);
		
		//the vectors that needs to be transformed 
		Vector3d v = new Vector3d(p.x,p.y,p.z);
		Vector3d V = new Vector3d();
		
		//Transformation matrix
		V = transformVector2(v,i,j,k,I,J,K);
		
		//Translate the Null node		
		m.setTranslation(V.x,V.y,V.z);
	}
	
	//derive to instantiate the new apex location
	{derive();}
	]
}

static Vector3d transformVector2(Vector3d v, Vector3d i, Vector3d j, Vector3d k, Vector3d I, Vector3d J, Vector3d K) {
	//Transforms the vector v from carthesian system i,j,k to vector V in terms of carthesian system I,J,K
	Vector3d V = new Vector3d();
	V.x = i.dot(I)*v.x + j.dot(I)*v.y + k.dot(I)*v.z;
	V.y = i.dot(J)*v.x + j.dot(J)*v.y + k.dot(J)*v.z;
	V.z = i.dot(K)*v.x + j.dot(K)*v.y + k.dot(K)*v.z;

	return V;
}

static boolean Barrier(Apex a) {
	//apex location
	Point3d loc = endlocation(a);
	
	//when the infiniteSoil is used, only roots growing to the surface are deflected
	double x = !infiniteSoil&&(loc.x>nrRows*rowDistance||loc.x<0) ? 1 : 0;
	double y = !infiniteSoil&&(loc.y>nrPlants*plantDistance||loc.y<0) ? 1 : 0;
	double z = loc.z<(-SoilDepth)||loc.z>0 ? 1 : 0;
	
	return (x>0||y>0||z>0) ? true : false;
}

static boolean deflectingRootSegment(RootOrgan a) {
	//rootsegment location
	Point3d loc = location(a);
	Point3d endloc = endlocation(a);
	
	//when the infiniteSoil is used, only roots growing to the surface are deflected
	double x = !infiniteSoil&&(loc.x<=nrRows*rowDistance&&loc.x>=0)&&(endloc.x>nrRows*rowDistance||endloc.x<0) ? 1 : 0;
	double y = !infiniteSoil&&(loc.y<=nrPlants*plantDistance&&loc.y>=0)&&(endloc.y>nrPlants*plantDistance||endloc.y<0) ? 1 : 0;
	double z = (loc.z>=(-SoilDepth)&&loc.z<=0)&&(endloc.z<(-SoilDepth)||endloc.z>0) ? 1 : 0;
	
	return (x>0||y>0||z>0) ? true : false;
}

static void rootDeflection(Apex a) {
//deflects a root if it hits the impenetrable surface of the pot walls or soil surface
	
	//find the root segment on the pots edge
	RootOrgan b = first((* a (<)* r:RootOrgan, (deflectingRootSegment(r))*)); 
	
	//variable initiation
	Point3d loc = endlocation(a);
	Matrix4d dir = new Matrix4d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	float e = 1;	//strength of the deflection
	
	//determine the axis of deflection
	//when the infiniteSoil is in used, only roots growing to the surface and the bottom are deflected
	double x = !infiniteSoil&&(loc.x>nrRows*rowDistance||loc.x<0) ? 1 : 0;
	double y = !infiniteSoil&&(loc.y>nrPlants*plantDistance||loc.y<0) ? 1 : 0;
	double z = loc.z<(-SoilDepth)||loc.z>0 ? 1 : 0;
	
	//initiate the plane along which deflection will take place
	Point3d plane = new Point3d(x,y,z);
	
	//do the deflection
	if(b!=null) {
		orthogonalTropism2(transformation(a),plane,e,dir);
		b[transform] = new TMatrix4d(dir);
	}
	
	derive();
}

static boolean orthogonalTropism2(Matrix34d m, Tuple3d direction, float e, Matrix4d out)
{ // alternative orthogonal tropism method
	Vector3d dir = new Vector3d (direction.z * m.m12 - direction.y * m.m22,
		direction.x * m.m22 - direction.z * m.m02, direction.y * m.m02
			- direction.x * m.m12);
	e *= Math.acos((m.m02 * direction.x + m.m12 * direction.y + m.m22 * direction.z)
					/ Math.sqrt ((m.m02 * m.m02 + m.m12 * m.m12 + m.m22 * m.m22) 
					* (direction.x * direction.x + direction.y * direction.y + direction.z * direction.z)))
					- 0.5 * Math.PI;
	if (e * e >= 1e-20)
	{
		Math2.invTransformVector (m, dir);
		out.set (new AxisAngle4d (dir, e));
		return true;
	}
	return false;
}

/********************************************************************************
	Soil
********************************************************************************/

class Soil {
	
	static double ExploredSoil;
	static double NrCells;
	static double N;
	static double exN; //N in explored soil
	static double P;
	static double exP; //P in explored soil
	
	static void Uptake() {
		if(sum((*RootSystem*)[CFlux])>0) [
			n:RichSoil ::> n.Uptake();
		] else {
			println("Roots stopped growing");
		}
	}
	
	static void Explore(GrowingRootOrgan a) [
		==> ^ 
			{//locate the exploring root
				Point3d loc = a instanceof Apex ? location(a) : endlocation(a);
				double x = Math.floor(loc.x/CellSize)*CellSize + CellSize/2;
				double y = Math.floor(loc.y/CellSize)*CellSize + CellSize/2;
				double z = Math.floor(loc.z/CellSize)*CellSize;
			}
			//make a new soil block if within plot limits
			if(x>0 && x<nrRows*rowDistance && y>0 && y<nrPlants*plantDistance && z<0) (
				RichSoil(x,y,z)
			);
			//consolidate the explored soil to avoid duplicates
			{ derive(); }
	]
	
	static void resetSoil() {
		ExploredSoil = 0;
		NrCells = (nrPlants*plantDistance/CellSize) * (nrRows*rowDistance/CellSize) * (SoilDepth/CellSize);
		N = NrCells * (10*CellSize)**3 * soilN[N_Scenario];
		P = NrCells * (10*CellSize)**3 * soilP[P_Scenario];
	}
}

//Soil cells explored by roots
abstract module ExploredSoil extends Box() {}

//Soil rich in N and/or P
module RichSoil extends ExploredSoil
{
	double volume 		= CellSize**3;
	double initN 		= volume * 1e3 * soilN[N_Scenario];
	double N;
	double initP	 	= volume * 1e3 * soilP[P_Scenario];
	double P;
	
	double exploredVolumeN;
	double exploredVolumeP;
	double exploredVolumeN_MF;
	double exploredVolumeP_MF;
	double sumUptakeN = 0;
	double sumUptakeP = 0;
	double sumUptakeN_MF = 0;
	double sumUptakeP_MF = 0;
	
	double a = 1;
	double b = 1;
	double c = 1;
	
	void Uptake() {		
		
		if(checkCmin()) [
			r:ExtendingRootOrgan, (endlocation(r) in volume(this)) ::> { calcPotUptakeN(r); calcPotUptakeP(r); calcPotUptakeMF(r); }
			r:ExtendingRootOrgan, (endlocation(r) in volume(this))::> { calcUptakeN(r); calcUptakeP(r); calcUptakeMF(r); }
		] else [
			this ==> DepletedSoil(location(this));
		]
		
		//reset instance variables
		sumUptakeN=0;
		sumUptakeP=0;
		sumUptakeN_MF=0;
		sumUptakeP_MF=0;
	}
	
	boolean checkCmin() {
		return true;
		// //check if the N and P concentrations are nearing the Cmin for roots and MF
		// //Using a cutofff point of 5%
		boolean r = N/(volume*1e3)>1.05*N_Cmin_r || P/(volume*1e3)>1.05*P_Cmin_r;
		boolean mf = N/(volume*1e3)>1.05*Math.min(N_Cmin_r,N_Cmin_mf) || P/(volume*1e3)>1.05*Math.min(P_Cmin_r,P_Cmin_mf);
		// //check in MF are present in the simulation
		boolean x = fMyc[0]+fMyc[1]>0 ? mf : r;
		return x;
	}
	
	static double disP(Point3d a, Point3d b) {
		//returns the distance between two points
		double dX = a.x-b.x;
		double dY = a.y-b.y;
		double dZ = a.z-b.z;
		double r = Math.sqrt(dX*dX + dY*dY + dZ*dZ);
		return r;
	}
	
	void calcPotUptakeN(ExtendingRootOrgan r) {
		if(r instanceof Apex) {//only primary and secondary roots facilitate N uptake
			//volume in L
			double vol = volume*1e3;
			//Available N
			double aN = Math.max(0, N - N_Cmin_r * vol);
			//newly explored soil volume by this Apex
			double newVolume = r.newRootLength * Math.PI * (N_UptakeRadius+0.5*r.D)**2;  		
			//The root takes up all N in the newly explore volume
			//This needs further consideration. Is all newly explore volume been uptaken
			r.Uptake_N = (volume-exploredVolumeN)>0 ? aN * Math.min(1,newVolume/(volume-exploredVolumeN)) : 0;
			//newly explored soil volume added to the fraction explored soil volume 
			exploredVolumeN :+= newVolume;
			//uptake added to total uptake counter
			sumUptakeN += r.Uptake_N;
		}
	}
	
	void calcPotUptakeP(ExtendingRootOrgan r) {
		//volume in L
		double vol = volume*1e3;
		//Available P
		double aP = Math.max(0, P - P_Cmin_r * vol);
		//root radius
		double rad = r instanceof Apex ? 0.5*r.D : 0.5*r.getFineRootD();
		//newly explored soil volume by this Apex/rootsegment
		double newVolume = r.newRootLength * Math.PI * (P_UptakeRadius+rad)**2;  		
		//The root takes up all P in the newly explored volume
		r.Uptake_P = (volume-exploredVolumeP)>0 ? aP * Math.min(1,newVolume/(volume-exploredVolumeP)) : 0;
		//newly explored soil volume added to the fraction explored soil volume 
		exploredVolumeP :+= newVolume;
		//uptake added to total uptake counter
		sumUptakeP += r.Uptake_P;
	}
	
	void calcPotUptakeMF(ExtendingRootOrgan r) {
		
		//volume in L
		double vol = volume*1e3;
		//new MF length
		double MFLength = r.MFnew/(Math.PI*MFradius**2 * MFTD*1e6);
		
		/*Nitrogen*/
		//Available N shared with roots
		double aN = Math.max(0, N - N_Cmin_r * vol);
		//newly explored soil volume by the mycorrhiza
		double newVolumeN_MF = MFLength * Math.PI * (N_UptakeRadius+MFradius)**2;
		//The mycorrhiza takes up all N in the newly explored volume
		r.Uptake_N_MF = (volume-exploredVolumeN)>0 ? aN * Math.min(1,newVolumeN_MF/(volume-exploredVolumeN)) : 0;
		//newly explored soil volume added to the fraction explored soil volume 
		exploredVolumeN :+= newVolumeN_MF;
		//update class variables
		sumUptakeN += r.Uptake_N_MF;
		
		if(N_Cmin_mf<N_Cmin_r) {
			//Available N not shared with roots
			double aN_MF = Math.max(0, N - N_Cmin_mf * vol) - aN;
			//The mycorrhiza takes up all N in the newly explored volume
			r.Uptake_N_MF_notshared = (volume-exploredVolumeN_MF)>0 ? aN_MF * Math.min(1,newVolumeN_MF/(volume-exploredVolumeN_MF)) : 0;
			//newly explored soil volume added to the fraction explored soil volume 
			exploredVolumeN_MF :+= newVolumeN_MF;
			//update class variables
			sumUptakeN_MF += r.Uptake_N_MF_notshared;
		}
		
		/*Phosphorus*/
		//Available P shared with roots
		double aP = Math.max(0, P - P_Cmin_r * vol);
		//newly explored soil volume by the mycorrhiza
		double newVolumeP_MF = MFLength * Math.PI * (P_UptakeRadius_MF+MFradius)**2;
		//The mycorrhiza takes up all P in the newly explored volume
		r.Uptake_P_MF = (volume-exploredVolumeP)>0 ? aP * Math.min(1,newVolumeP_MF/(volume-exploredVolumeP)) : 0;
		//update class variables
		sumUptakeP += r.Uptake_P_MF;
			
		if(P_Cmin_mf<P_Cmin_r) {
			//Available P not shared with roots
			double aP_MF = Math.max(0, P - P_Cmin_mf * vol) - aP;
			//The mycorrhiza takes up all N in the newly explored volume
			r.Uptake_P_MF_notshared = (volume-exploredVolumeP_MF)>0 ? aP_MF * Math.min(1,newVolumeP_MF/(volume-exploredVolumeP_MF)) : 0;
			//newly explored soil volume added to the fraction explored soil volume 
			exploredVolumeP_MF :+= newVolumeP_MF;
			//update class variables
			sumUptakeP_MF += r.Uptake_P_MF_notshared;
		}
	}
	
	void calcUptakeN(ExtendingRootOrgan r) { 
		//volume in L
		double vol = volume*1e3;
		//Available N for root
		double aN = N - Math.max(0, N_Cmin_r * vol);
		//Uptake roots
		double uptRoot = sumUptakeN>0 ? Math.max(0,Math.min(r.Uptake_N, aN * r.Uptake_N/sumUptakeN)) : 0;
		
		N :-= uptRoot;
		Soil.exN -= uptRoot;
		r.Uptake_N = uptRoot;
	}
	
	void calcUptakeP(ExtendingRootOrgan r) {
		//volume in L
		double vol = volume*1e3;
		//Available P for roots
		double aP = Math.max(0, P - P_Cmin_r * vol);
		//Uptake roots
		double uptRoot = sumUptakeP>0 ? Math.max(0,Math.min(r.Uptake_P, aP * r.Uptake_P/sumUptakeP)) : 0;
		
		P :-= uptRoot;
		Soil.exP -= uptRoot;
		r.Uptake_P = uptRoot;
		
		setShader(new RGBAShader(1-(P/initP),1-(P/initP),1-(P/initP)));
	}
	
	void calcUptakeMF(ExtendingRootOrgan r) { 
		
		//volume in L
		double vol = volume*1e3;
		
		/*Nitrogen*/
		//Available N shared with roots
		double aN = N - Math.max(0, N_Cmin_r * vol);
		//Available N not shared with roots
		double aN_MF = Math.max(0, N - N_Cmin_mf * vol)-aN;
		//Uptake MF from the N shared with the roots
		double NuptMF1 = sumUptakeN>0 ? Math.max(0,Math.min(r.Uptake_N_MF, aN * r.Uptake_N_MF/sumUptakeN)) : 0;
		//Uptake MF from the N not shared with the roots
		double NuptMF2 = sumUptakeN_MF>0 ? Math.max(0,Math.min(r.Uptake_N_MF_notshared, aN_MF * r.Uptake_N_MF_notshared/sumUptakeN_MF)) : 0;
		
		//combined uptake
		double NuptSum = NuptMF1 + NuptMF2;
		
		N :-= NuptSum;
		Soil.exN -= NuptSum;
		r.Uptake_N_MF = NuptSum;
		
		/*Phosphorus*/
		//Available P shared with roots
		double aP = P - Math.max(0, P_Cmin_r * vol);
		//Available P not shared with roots
		double aP_MF = Math.max(0, P - P_Cmin_mf * vol)-aP;
		//Uptake MF from the P shared with the roots
		double PuptMF1 = sumUptakeP>0 ? Math.max(0,Math.min(r.Uptake_P_MF, aP * r.Uptake_P_MF/sumUptakeP)) : 0;
		//Uptake MF from the P not shared with the roots
		double PuptMF2 = sumUptakeP_MF>0 ? Math.max(0,Math.min(r.Uptake_P_MF_notshared, aP_MF * r.Uptake_P_MF_notshared/sumUptakeP_MF)) : 0;
		
		//combined uptake
		double PuptSum = PuptMF1 + PuptMF2;
		
		P :-= PuptSum;
		Soil.exP -= PuptSum;
		r.Uptake_P_MF = PuptSum;
	}
	
	public RichSoil(double x, double y, double z) {
		 
	}
	
}

//Soil depleted of N and P
module DepletedSoil extends ExploredSoil {

	public DepletedSoil(Point3d L) {
		length=width=height=CellSize*1.001;
		setTranslation(L.x,L.y,L.z);
		setLayer(GridPointLayer);
		setShader(WHITE);
	}
}

/********************************************* 
				INITIATION
************************************************/

static void initSoil() {	//@Init
	
	if(true) {
		Soil.resetSoil();
		// Box for visualisation
		[ ==> ^
			[	RU(90) F(nrRows*rowDistance, 0.002, 0).(setLayer(BoxLayer))
				[RU(90) F(SoilDepth, 0.002, 0).(setLayer(BoxLayer))]
				RL(-90) F(nrPlants*plantDistance, 0.002, 0).(setLayer(BoxLayer))
				[RU(90) F(SoilDepth, 0.002, 0).(setLayer(BoxLayer))]
				RL(-90) F(nrRows*rowDistance, 0.002, 0).(setLayer(BoxLayer))
				[RU(90) F(SoilDepth, 0.002, 0).(setLayer(BoxLayer))]
				RL(-90) F(nrPlants*plantDistance, 0.002, 0).(setLayer(BoxLayer))
				RU(90)  F(SoilDepth, 0.002, 0).(setLayer(BoxLayer))
				RU(90)  F(nrPlants*plantDistance, 0.002, 0).(setLayer(BoxLayer))
				RL(-90) F(nrRows*rowDistance, 0.002, 0).(setLayer(BoxLayer))
				RL(-90) F(nrPlants*plantDistance, 0.002, 0).(setLayer(BoxLayer))
				RL(-90) F(nrRows*rowDistance, 0.002, 0).(setLayer(BoxLayer))		
			];
		]
	}
}

